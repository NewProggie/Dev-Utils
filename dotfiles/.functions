# create a new directory and enter it
function mkd() {
    mkdir -p "$@" && cd "$_";
}

# `tre` is a shorthand for `tree` with hidden files and color enabled, ignoring
# the `.git` directory, listing directories first. The output gets piped into
# `less` with options to preserve color and line numbers, unless the output is
# small enough for one screen.
function tre() {
    tree -aC -I '.git|node_modules|bower_components' --dirsfirst "$@" | less -FRNX;
}

# colorized man pages
function man() {
    env \
        LESS_TERMCAP_mb=$(printf "\e[1;31m") \
        LESS_TERMCAP_md=$(printf "\e[1;31m") \
        LESS_TERMCAP_me=$(printf "\e[0m") \
        LESS_TERMCAP_se=$(printf "\e[0m") \
        LESS_TERMCAP_so=$(printf "\e[1;44;33m") \
        LESS_TERMCAP_ue=$(printf "\e[0m") \
        LESS_TERMCAP_us=$(printf "\e[1;32m") \
            man "$@"
}

# plot stuff directly from the command line.
# Example: seq 100 | sed 's/.*/s(&)/' | bc -l | plot linecolor 2
# -> Generate 100 numbers, wrap it in s(<num>) and calc sin(<num>)
function plot() {
    { echo 'plot "-"' "$@"; cat; } | gnuplot -persist;
}

# wrapper for easy extraction of compressed files
function extract () {
  if [ -f $1 ] ; then
      case $1 in
          *.tar.xz)    tar xvJf $1    ;;
          *.tar.bz2)   tar xvjf $1    ;;
          *.tar.gz)    tar xvzf $1    ;;
          *.bz2)       bunzip2 $1     ;;
          *.rar)       unrar e $1     ;;
          *.gz)        gunzip $1      ;;
          *.tar)       tar xvf $1     ;;
          *.tbz2)      tar xvjf $1    ;;
          *.tgz)       tar xvzf $1    ;;
          *.apk)       unzip $1       ;;
          *.epub)      unzip $1       ;;
          *.xpi)       unzip $1       ;;
          *.zip)       unzip $1       ;;
          *.war)       unzip $1       ;;
          *.jar)       unzip $1       ;;
          *.Z)         uncompress $1  ;;
          *.7z)        7z x $1        ;;
          *)           echo "don't know how to extract '$1'..." ;;
      esac
  else
      echo "'$1' is not a valid file!"
  fi
}

# find executable binarys in given path
function find_exec() {
    if [[ -z "$1" ]]; then
        echo "No argument supplied"
        return 1
    fi
    case "${OSTYPE}" in
      darwin*) find $1 -perm +111 -type f ;;
      linux*)  find $1 -executable -type f ;;
      *)       echo "unknown ${OSTYPE}" ;;
    esac
}

# get number of logical cpu cores
function cores() {
    case "${OSTYPE}" in
      darwin*) sysctl -n hw.ncpu ;;
      linux*)  grep ^processor /proc/cpuinfo | wc -l ;;
      *)       echo "unknwon ${OSTYPE}" ;;
    esac
}

# dump compiler include paths
function include_paths() {
    local comp="c"
    if [[ -z "${1}" ]]; then
        echo "No compiler as argument supplied"
        return 1
    fi
    if [[ "${1}" == *++ ]]; then
        comp="c++"
    fi
    ${1} -E -x ${comp} - -v < /dev/null
}

# start clean bash without any env paths set
function clean_bash() {
    env -i bash --noprofile --norc
}

# start ssh-agent to avoid reentering passphrase
function start_ssh_agent() {
    echo "Initialising new SSH agent..."
    eval "$(ssh-agent -s)"
    ssh-add
}

# recall what I did on the last working day
function git_standup() {
    usage() { echo -e "git_standup \n\t[-a <author>]\n\t[-d <days-ago>]" 1>&2; }

    AUTHOR=$(git config user.name)
    SINCE="yesterday"
    GIT_PRETTY_FORMAT='%Cred%h%Creset - %s %Cgreen(%cd) %C(bold blue)<%an>%Creset'

    local OPTIND
    while getopts "hd:a:" opt; do
        case ${opt} in h|d|a)
            declare "option_${opt}=${OPTARG:-0}" ;; \?)
        esac
    done
    shift $((OPTIND-1))

    if [[ ${option_h} ]]; then usage; return; fi

    if [[ ${option_a} ]]; then AUTHOR="$option_a"; fi

    if [[ ${option_d} ]] && [[ ${option_d} -ne 0 ]]; then
        SINCE="${option_d} days ago"
    fi

    GIT_LOG_COMMAND="git --no-pager log \
      --all
      --no-merges
      --since=\"${SINCE}\"
      --author=\"${AUTHOR}\"
      --abbrev-commit
      --oneline
      --pretty=format:'${GIT_PRETTY_FORMAT}'
      --date='relative'"

    GIT_OUT=$(eval ${GIT_LOG_COMMAND} 2> /dev/null)
    if [[ ! -z "${GIT_OUT}" ]]; then
        echo "${GIT_OUT}"
    else
        echo "Seems like ${AUTHOR} did nothing!"
    fi
}
